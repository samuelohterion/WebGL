<!doctype html>

<html>
	<head>
		<script>
		</script>
	</head>
	<body>

		<canvas width = "800" height = "800" id = "myCanvas">
		</canvas>

		<script id="vertex-shader" type="not-javascript">

		   attribute vec3 coordinates;
		   attribute vec3 color;

		   varying   vec3 vColor;
		   varying   vec3 vPosition;

		   void main( void ) {
		   
				gl_Position = vec4( coordinates, 1. );
				vColor = color;
				vPosition = coordinates;
			}
   	</script>

		<script id="fragment-shader" type="not-javascript">

			precision mediump float;

			uniform float uTime;			
			
			varying vec3 vColor;
			varying vec3 vPosition;
			
			bool 
			hitBall( vec3 e, vec3 r, vec3 p, float rad, inout float l, inout vec3 h, inout vec3 n ) {

				vec3 d = e - p;

				float 
				ab = dot( r, d ),
				bb = dot( d, d ),
				ds = ( rad * rad - bb ) + ab * ab;		

				if( 0. <= ds ) {

					float	 
					ln = -ab - sqrt( ds );

					if( l < ln || ln < 0.)
					
						return false;

					l = ln;
					h = e + l * r;
					n = normalize( h - p );

					return true;
				}
				
				return false;
			}
			
			void 
			main( void ) {
			   	
		 		vec3
	 			lgt = vec3( -1., -1., +4. ),
		 		eye = vec3( 0., 0., 3. ),
				ray = normalize( vPosition - eye ),
				pos = vec3( .0, sin( uTime ), -2. ),
				hit,
				nrm;
				
				float
				rad = 1.,
				len = 1e5;
				
				bool
				ht = hitBall( eye, ray, pos, rad, len, hit, nrm );
				
				if( ht ) {
				
					vec3
					lh = normalize( lgt - hit );
					
					gl_FragColor = vec4( .1 + dot( lh, nrm ) * vec3( .7, .8, .9 ), 1. );
				}
				else {
				
					gl_FragColor = vec4( .1, .2, .4, 1. );
				}
			} 
		</script>

   	<script type="text/javascript">

			/*============ Creating a canvas =================*/
			var cv = document.getElementById('myCanvas');
			var gl = cv.getContext('experimental-webgl');
			
			function createVectorArrayF32(datas) {
				var buffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(datas), gl.STATIC_DRAW);
				gl.bindBuffer(gl.ARRAY_BUFFER, null);
				return buffer;
			}
			
			function createIndexArrayUI16(datas) {
				var buffer = gl.createBuffer();
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
				gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(datas), gl.STATIC_DRAW);
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
				return buffer;
			}
			
			function createShader(shaderScript, shaderType) {
				var shader = gl.createShader(shaderType);
				gl.shaderSource(shader, shaderScript);
				gl.compileShader(shader);
				return shader;
			}
			
			function createShaderProgram(vShader, fShader) {
					var shaderProgram = gl.createProgram();
					gl.attachShader(shaderProgram, vShader);
					gl.attachShader(shaderProgram, fShader);
					gl.linkProgram(shaderProgram);
					gl.useProgram(shaderProgram);
					return shaderProgram;
				}
				

			/*========== Datas =========*/
			
			var locTime = 0.;

			var vertices = [
			
				-1.0, -1.0, +0.0,
				+1.0, -1.0, +0.0, 
				+1.0, +1.0,	+0.0,
				-1.0, +1.0, +0.0
			];
				
			var colors = [

				0.0, 0.0, 1.0,	
				1.0, 0.0, 0.0,
				0.0, 1.0, 0.0,
				0.3, 0.3, 0.3
			];
			
			var indices = [

				0, 1, 2,
				2, 3, 0
			];
			
			

			/*========== Defining and storing the geometry =========*/
			
			var vertexBuffer = createVectorArrayF32(vertices);
			var indexBuffer = createIndexArrayUI16(indices);
			var colorBuffer = createVectorArrayF32(colors);
			


			/*====================== Shaders =======================*/
			
			var vertShaderSource = document.getElementById( "vertex-shader" ).text;
			var fragShaderSource = document.getElementById( "fragment-shader" ).text;
			
			var vertShader = createShader( vertShaderSource, gl.VERTEX_SHADER);
			var fragShader = createShader( fragShaderSource, gl.FRAGMENT_SHADER );
			   

			// Create a shader program object to
			// store the combined shader program
			var shaderProgram = createShaderProgram(vertShader, fragShader);
			

			/* ======= Associating shaders to buffer objects =======*/

			// Bind vertex buffer object
			gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
			
			// Bind index buffer object
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
			
			// Get the attribute location
			var coord = gl.getAttribLocation(shaderProgram, "coordinates");
			
			// Point an attribute to the currently bound VBO
			gl.vertexAttribPointer(coord, 3, gl.FLOAT, false, 0, 0);
			
			// Enable the attribute
			gl.enableVertexAttribArray(coord);
			

			// bind the color buffer
			gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
			
			var color = gl.getAttribLocation(shaderProgram, "color");

			gl.vertexAttribPointer(color, 3, gl.FLOAT, false, 0, 0);

			gl.enableVertexAttribArray(color);
			
//			gl.bindBuffer( gl.ARRAY_BUFFER, 0 );
//			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, 0 );
			

			/*============= Drawing the Quad ================*/
			
			requestAnimationFrame( draw );			
			

			function draw( ) {
				
				locTime += 1. / 60.;
				
				var uTimeLoc = gl.getUniformLocation( shaderProgram, "uTime" );
				
				gl.uniform1f( uTimeLoc, locTime );				
				
				// Clear the canvas
				gl.clearColor(.95, .95, .95, 1.);
				
				// Enable the depth test
				gl.enable(gl.DEPTH_TEST);
				
				// Clear the color buffer bit
				gl.clear(gl.COLOR_BUFFER_BIT);
				
				// Set the view port
				gl.viewport( 0, 0, cv.width, cv.height);
				
				// Draw the triangle
				gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
				
				requestAnimationFrame(draw);
			}

		</script>

	</body>

</html>

